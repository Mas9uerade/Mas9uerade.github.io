# struct和class的区别

**class和struct最本质的区别是class是引用类型，而struct是值类型，它们在内存中的分配情况有所区别。**

什么是class?

class（类）是面向对象编程的基本概念，是一种自定义数据结构类型，通常包含字段、属性、方法、属性、构造函数、索引器、操作符等。在.NET中，所有的类都最终继承自System.Object类，因此是一种引用类型，也就是说，new一个类的实例时，在堆栈（stack）上存放该实例在**托管堆（managed heap）中的地址**，而实例的值保存在**托管堆（managed heap）**中。

什么是struct?

struct（结构）是一种值类型，用于将一组相关的变量组织为一个单一的变量实体 。所有的结构都继承自System.ValueType类，因此是一种值类型，也就是说，struct实例在创建时分配在线程的**堆栈（stack）**上，它本身存储了值。所以在使用struct时，我们可以将其当作int、char这样的基本类型类对待。

# 值类型和引用类型区别

什么是值类型：

- 进一步研究文档，你会发现所有的结构都是抽象类型System.ValueType的直接派生类，而System.ValueType本身又是直接从System.Object派生的。根据定义所知，所有的值类型都必须从System.ValueType派生，所有的枚举都从System.Enum抽象类派生，而后者又从System.ValueType派生。  
-  所有的值类型都是隐式密封的（sealed），目的是防止其他任何类型从值类型进行派生。 

什么是引用类型：

- 在c#中所有的类都是引用类型，包括接口。

 区别和性能

- 区别：

  - 值类型通常被人们称为轻量级的类型，因为在大多数情况下，值类型的的实例都分配在线程栈中，因此它不受垃圾回收的控制，缓解了托管堆中的压力，减少了应用程序的垃圾回收的次数，提高性能。
  - 所有的引用类型的实例都分配在托管堆上，c#中new操作符会返回一个内存地址指向当前的对象。所以当你在创建个一个引用类型实例的时候，你必须要考虑以下问题：
    - 内存是在托管堆上分配的
    - 在分配每一个对象时都会包含一些额外的成员（类型对象指针，同步块索引），这些成员必须初始化
    - 对象中的其他字节总是设为零
    - 在分配对象时，可能会进行一次垃圾回收操作（如果托管堆上的内存不够分配一次对象时）

- 性能：

  - 在设计一个应用程序时，如果都是应用类型，那么应用程序的性能将显著下降，因为这会加大托管堆的压力，增加垃圾回收的次数。
  - 虽然值类型是一个轻量级的类型，但是如果大量的使用值类型的话，也会有损应用程序的性能（例如下面要讲的装箱和拆箱操作，传递实例较大的值类型，或者返回较大的值类型实例）。
  - 由于值类型实例的值是自己本身，而引用类型的实例的值是一个引用，所以如果将一个值类型的变量赋值给另一个值类型的变量，会执行一次逐字段的复制，将引用类型的变量赋值给另一个引用类型的变量时，只需要复制内存地址，所以在对大对象进行赋值时要避免使用值类型。例如下面的代码

  ```c#
  class SomRef
  {
    	public int x;
  }
  struct SomeVal 
  {
  		public int x;
  }
  
  class Program 
  {
  
  		static void ValueTypeDemo() 
      {
  
  			SomRef r1 = new SomRef();//在堆上分配
  
  			SomeVal v1 = new SomeVal();//在栈上分配
  
  			r1.x = 5;//提领指针
  			v1.x = 5;//在栈上修改
  
    			SomRef r2 = r1;//只复制引用（指针）
  
    			SomeVal v2 = v1;//在栈上分配并复制成员
    		}
  
    }
  ```



值类型传参进函数的修改，在出栈后不保留直接丢弃了；

引用类型传参进函数后，修改会保留，因为在托管堆中；

# C#装箱和拆箱

```c#
int i = 5;

object o = i;

int j = (int)o;

Int16 y=(Int16)o;
```

什么是装箱，什么是拆箱

- 什么是装箱：所谓装箱就是将值类型转化为引用类型的过程(例如上面代码的第2行)，在装箱时，你需要知道编译器内部都干了什么事：
  - 在托管堆中分配好内存，分配的内存量是值类型的各个字段需要的内存量加上托管堆上所以对象的两个额外成员（类型对象指针，同步块索引）需要的内存量
  - 值类型的字段复制到新分配的堆内存中
  - 返回对象的地址，这个地址就是这个对象的引用
- 什么是装箱：将已装箱的值类型实例（此时它已经是引用类型了）转化成值类型的过程（例如上面代码的第3行），注意：拆箱不是直接将装箱过程倒过来，拆箱的代价比装箱要低的多，拆箱其实就是获取一个指针的过程。一个已装箱的实例在拆箱时，编译器在内部都干了下面这些事：
  - 如果包含了“对已装箱类型的实例引用”的变量为null时，会抛出一个NullReferenceException异常。
  - 如果引用指向的对象不是所期待的值类型的一个已装箱实例，会抛出一个InvalidCastException异常(例如上面代码的第4行)。  

1. 它们在什么情况下发生，以及如何避免

```c#
static void Main(string[] args)
{

int v = 5;

object o = v;

v = 123;

Console.WriteLine(v+","+(int)o);

}
```

通过上面的分析我们已经知道了，装箱和拆箱/复制操作会对应用程序的速度和内存消耗产生不利的影响（例如消耗内存，增加垃圾回收次数，复制操作），所以我们应该注意编译器在什么时候会生成代码来自动这些操作，并尝试手写这些代码，尽量避免自动生成代码的情况。

- 你能一眼从上面的代码中看出进行了几次装箱操作吗？正取答案是3次。分别进行了哪三次呢，我们来看一下：第一次object o=v;第二次在执行 Console.WriteLine(v+","+(int)o);时将v进行装箱，然后对o进行拆箱后又装箱。也就是说装箱过程总是在我们不经意的时候进行的，所以只有我们充分了解了装箱的内部机制，才能有效的避免装箱操作，从而提高应用程序的性能。所以对上面的代码进行如下修改可以减少装箱次数，从而提高性能：

```c#
static void Main(string[] args)
{

 int v = 5;

 object o = v;

 v = 123;

 Console.WriteLine(v.ToString() + "," + ((int)o).ToString());//((int)o).ToString()代码本身没有任何意义，只为演示装箱和拆箱操作

}
```

- 下面来讨论一下编译器都会在什么时候自动生成代码来完成这些操作
  - 使用非泛型集合时：比如ArrayList,因为这些集合需要的对象都是object,如果你将一个值类型的对象添加到集合中时会执行一次装箱操作，当你取值时会执行一次拆箱操作，所以在应用程序中应避免使用这种非泛型的集合。
  - 大家都知道System.Object是所有类型的基类，当你调用object类型的非虚方法时会进行装箱操作（例如GetType方法）。在调用object的虚方法时，如果你的值类型没有重写虚方法也要进行装箱操作，所以在定义自己的值类型时，应重写object内部的虚方法（例如ToString方式）
  - 将值类型转化为接口类型时也会进行装箱操作，这是因为接口类型必须包含对堆上的一个对象的引用。

#### 三，泛型的出现（本节只简单介绍泛型对装箱和拆箱所起的作用，关于泛型的具体细节请参考下一篇文章）

- -  什么泛型

    - 泛型是CLR和编程语言提供的一种特殊机制，它在c#2中才被提供出来。

  -  它对避免装箱有什么作用？

    - 在使用泛型时需要指定要装配的类型，这样可以减少装箱操作，比如下面的代码

    ```c#
    static void Main(string[] args)
    {
      ArrayList dateList = new ArrayList {DateTime.Now};
    
      IList<DateTime> dateT = new List<DateTime> {
      DateTime.Now
      };
    
    }
    ```

    

#### 四，在设计时如何选择类和结构体

在面试的时候，我们经常被问的一个问题（还有另外一个问题，如何选择抽象类和接口，下次我会单独聊聊这个问题），下面我们来聊聊在设计时应该如何选择结构体和类

- -  什么是结构体
    - 结构体是一种特殊的值类型，所以它拥有值类型所以的特权（实例一般分配在线程栈上）和限制（不能被派生，所以没有 abstract 和 sealed，未装箱的实例不能进行线程同步的访问）。
  -  什么情况下选择结构体，什么情况下选择类
    - 在大多数的情况下，都应该选择类，除非满足以下情况，才考虑选择结构体：
    - 类型具有基元类型的行为
    - 类型不需要从其它任何类型继承
    - 类型也不会派生出任何其它类型
    - 类型的实例较小（约为16字节或者更小）
    - 类型的实例较大，但是不作为方法的参数传递，也不作为方法的返回值。